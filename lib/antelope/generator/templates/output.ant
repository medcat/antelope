Productions:
{{
  len = grammar.all_productions.size.to_s.size
  productions = grammar.all_productions.
    map { |x| ["#{x.label}: #{x.items.join(' ')}", x.block] }
  body = productions.map { |_| _.first.size }.max
}}
{{ productions.each_with_index do |prod, i| }}
  {{=  "%#{len}s" % i }} {{=  "%-#{body}s" % prod[0] }} {{=  prod[1] }}
{{ end }}

{{ if unused_symbols.any? }}
Symbols unused in grammar:
{{   unused_symbols.each do |sym| }}
  {{=  sym }}
{{   end }}
{{ end }}

Precedence:
  --- highest
{{ grammar.precedence.each do |pr| }}
  {{=  "%-8s" % pr.type }} {{=  pr.level }}:
    { {{=  pr.tokens.to_a.join(", ") }} }
{{ end }}
  --- lowest

{{
  len = tableizer.table.flatten.map(&:keys).flatten.map(&:size).max
  states = grammar.states.to_a
}}

{{ tableizer.table.each_with_index do |v, i| }}
{{   state = states[i] }}
  State {{=  i }}:
{{   state.rules.each do |rule| }}
    {{=  rule }}
      { {{=  rule.lookahead.to_a.join(", ") }} }
{{   end }}
{{
  transitions = v.each.select { |_, a| a && a[0] == :state }
  reductions  = v.each.select { |_, a| a && a[0] == :reduce}
  accepting   = v.each.select { |_, a| a && a[0] == :accept}
  conflicts   = tableizer.conflicts[i].each
  thing = [:transitions, :reductions, :accepting]
  num_type = {
    transitions: "State",
    reductions: "Rule",
    accepting: "Rule"
  }
  h = Hash[thing.zip([transitions, reductions, accepting])]
}}
{{   h.each do |key, value| }}
{{     next unless value.any? }}
    {{=  key }}:
{{     value.each do |token, (_, name)| }}
{{       token_value = grammar.terminals.find { |_| _.name == token } || token }}
      {{=  token_value }}: {{=  num_type[key] }} {{=  name }}
{{     end }}
{{   end }}
{{   if conflicts.any? }}
    conflicts:
{{     conflicts.each do |token, (first, second, rule, terminal)| }}
      {{=  token }}: {{=  first.join(" ") }}/{{=  second.join(" ") }} ({{=  rule }} vs {{=  terminal }})
{{     end }}
{{   end }}

{{ end }}
